# generated by datamodel-codegen:
#   filename:  petrinet_schema.json
#   timestamp: 2023-10-13T14:48:27+00:00

from __future__ import annotations

from typing import Any, Dict, List, Optional

from pydantic import AnyUrl, BaseModel, ConfigDict, Field, RootModel


class Header(BaseModel):
    model_config = ConfigDict(protected_namespaces=(), populate_by_name=True)
    name: str
    schema_: AnyUrl = Field(..., alias="schema")
    schema_name: Optional[str] = None
    description: str
    model_version: Optional[str] = None


class Rate(BaseModel):
    target: Optional[str] = None
    expression: Optional[str] = None
    expression_mathml: Optional[str] = None


class Initial(Rate):
    pass


class Distribution(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    type: str
    parameters: Dict[str, Any]


class Grounding(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    identifiers: Dict[str, Any]
    modifiers: Optional[Dict[str, Any]] = None


class Properties(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    name: str
    description: Optional[str] = None
    grounding: Optional[Grounding] = None


class Unit(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    expression: Optional[str] = None
    expression_mathml: Optional[str] = None


class Observable(BaseModel):
    id: str
    name: Optional[str] = None
    expression: Optional[str] = None
    expression_mathml: Optional[str] = None


class Parameter(BaseModel):
    id: str
    name: Optional[str] = None
    description: Optional[str] = None
    value: Optional[float] = None
    grounding: Optional[Grounding] = None
    distribution: Optional[Distribution] = None
    units: Optional[Unit] = None


class Time(BaseModel):
    id: str
    units: Optional[Unit] = None


class OdeSemantics(BaseModel):
    rates: Optional[List[Rate]] = None
    initials: Optional[List[Initial]] = None
    parameters: Optional[List[Parameter]] = None
    observables: Optional[List[Observable]] = None
    time: Optional[Time] = None


class State(BaseModel):
    id: str
    name: Optional[str] = None
    description: Optional[str] = None
    grounding: Optional[Grounding] = None
    units: Optional[Unit] = None


class States(RootModel[List[State]]):
    root: List[State]

    def __iter__(self):
        return iter(self.root)

    def __getitem__(self, item):
        return self.root[item]


class Transition(BaseModel):
    id: str
    input: List[str]
    output: List[str]
    grounding: Optional[Grounding] = None
    properties: Optional[Properties] = None


class Transitions(RootModel[List[Transition]]):
    root: List[Transition]

    def __iter__(self):
        return iter(self.root)

    def __getitem__(self, item):
        return self.root[item]


class Model1(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    states: States
    transitions: Transitions


class Semantics(BaseModel):
    ode: Optional[OdeSemantics] = None
    typing: Optional[TypingSemantics] = Field(
        None,
        description="(Optional) Information for aligning models for stratification",
    )
    span: Optional[List[TypingSemantics]] = Field(
        None,
        description="(Optional) Legs of a span, each of which are a full ASKEM Petri Net",
    )


class Model(BaseModel):
    model_config = ConfigDict(
        extra="allow",
    )
    header: Header
    properties: Optional[Dict[str, Any]] = None
    model: Model1
    semantics: Optional[Semantics] = Field(
        None,
        description="Information specific to a given semantics (e.g., ODEs) associated with a model.",
    )
    metadata: Optional[Dict[str, Any]] = Field(
        None,
        description="(Optional) Information not useful for execution of the model, but that may be useful to some consumer in the future. E.g. creation timestamp or source paper's author.",
    )


class TypingSemantics(BaseModel):
    system: Model = Field(
        ...,
        description="A Petri net representing the 'type system' that is necessary to align states and transitions across different models during stratification.",
    )
    map: List[List[str]] = Field(
        ...,
        description="A map between the (state and transition) nodes of the model and the (state and transition) nodes of the type system",
    )


Semantics.model_rebuild()
Model.model_rebuild()
